PROCESS CREATION AND MANAGEMENT 13-OCT
The language is independent but as soon as you have included some libraries your program is dependent to the OS.
After the compiler compiles the program, the compiled program should be made in a way such that when you move it to
the main memory, then the OS finds all the instructions and the data in some specific order, because the program is
executed one instruction after the other, there is no reason to have them ordered in a random way. So the instructions
are stored in a specific order so in the executable, so it can be brought to the main memory
 in the so call imaged process.

Typical any binary executable has a header (information on the platform that can run the program
(type of HW, OS required libraries etc.)).
Then there is the text segment, is the portion of the process image that contain the sequence of
binary instructions of the program.
The Data segment is the place where there are all the initialised data, anything in which
we have variable with fixed size or fixed content.

showing exercise on etext edata and end

PART 2

Parent child relationship

• All processes in Linux (UNIX) are generated by a parent process
• Accordingly, each process in Linux (UNIX) is the child of another process
• Each process has a PID - process identifier
• The PPID - parent process identifier – is also associated to each process
• You can see the list of all active processes in your machine using       ps -el

In the process relationship tree, we can create the tree only starting from any processes and going up in the hierarchy,
and not vice-versa, because the process one does not know who are the children, unless the programmer
store somewhere the children pid.

FORK FUNCTION

 This is the system call to create a process

Include files: <sys/types.h>
		<unistd.h>

 Prototype: pid_t fork(void)

Return values:
 0 		to the child process
 PID 		of the child to the parent process
 -1 		in the case the system call fork fails

FUNCTION FORK

First the process starts, with the use of fork we are calling the OS, so our process is put on hold,
from the perspective of the process state, when fork is called, the process is still running, because calling
the kernel we are not switching to another process, we are just changing the mode, from user to kernel mode,
but the process is still running.
When we call fork, the OS creates a new process and this process is an exact copy of the parent process,
and then fork returns a value. After the new process is created the return value that is given by the OS
to the child process is zero, then the parent process receives the pid of the child that have been created.
So we have two copies of the same process that are running, and they will start to the next instruction of the fork.
So we call fork() the program counter has the same values in the two processes, but the trick is that the return
value of the fork is different from child (0) and for parent (pid). And this is the only way, if you are interested,
in which you can store that value in a variable.
In a switch construct the case 0 will be executed by the child, the default will be executed by the parent.

REMEMBER: behind this idea there is the concept that we want to create processes that cooperate between each other.
It is to make them cooperate because they are the same copy, and start from the same variables.

With fork we re going to copy the heap, the stack and also the u area: the file descriptors of all open files,
so if the parent opened 3 files, the child also find this file open and exactly in the same position in which
the parent open-end those files. It is important for the communication.

*     Switching to linux   ****************************************************************
implementing fork_example
Note: any time we will call system calls we will have to check if there is an error. Like in fork()

PART 3

PROCESS ENVIRONMENT
So the PID is a sort of counter, so the OS increments this number one by one, it is an integer.
The call getpid() return the PID of the calling process.
And the getppid() return the PPID (parent PID) of the calling process.
You cannot get the PID of the process you have created (child). There are not system calls for that.

Now let's try to use the wait function: (fork_example_wait)
Typically, the value 0 is used for the correct termination of the process,
 while other numbers (typically greater than 0) are used to code different error types


If you want the child to tell the parent process, or the OS, something about
the reason why the process have terminated, you can put a code in exit.
How the parent process can capture this value: with the function called wait().
If you are a parent process, and you want to get the value of exit you have to wait for the child to terminate.
When the process is waiting the process is in the blocked state.

we are putting the exit on the end of the child and the wait before the end of the parent.

examples with asleep to make zombie process

Now what happens when a child process create another child process?
fork_example_child_chain.c

Imaging that for any reason you have to create 4 process, so we need a for loop..
The output is a mess
The issue is that for the child process (case 0) we put a break.
The break means exit from this switch, but not from the for loop, so it will go on with
value of i that the child has.
The correction is to put exit in the child.
So the last one parent is one, if we do not want this behaviour we have to wait in the parent.

